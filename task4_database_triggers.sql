-- 1.   Написать DML-триггер, регистрирующий изменение данных (вставку, обновление, удаление)
-- в одной из таблиц БД. Во вспомогательную таблицу LOG1 записывать, кто, когда (дата и время)
-- и какое именно изменение произвел, для одного из столбцов сохранять старые и новые значения.

SET SERVEROUTPUT ON;

CREATE TABLE LOG1
(
    LOG_ID      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USERNAME    VARCHAR2(30),
    ACTION      VARCHAR2(10),
    OLD_VALUE   VARCHAR2(255),
    NEW_VALUE   VARCHAR2(255),
    CHANGE_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE TRIGGER trg_team_log
    AFTER INSERT OR UPDATE OR DELETE ON LW1_TEAM FOR EACH ROW
DECLARE
    v_username VARCHAR2(30);
    v_action VARCHAR2(10);
    v_old_value VARCHAR2(255);
    v_new_value VARCHAR2(255);
BEGIN
    -- Получаем имя пользователя
    v_username := USER;

    CASE
        WHEN INSERTING THEN
            v_action := 'INSERT';
            v_new_value := :NEW.MEMBERS;

        WHEN UPDATING THEN
            v_action := 'UPDATE';
            v_old_value := :OLD.MEMBERS;
            v_new_value := :NEW.MEMBERS;

        WHEN DELETING THEN
            v_action := 'DELETE';
            v_old_value := :OLD.MEMBERS;
        END CASE;

    INSERT INTO LOG1(USERNAME, ACTION, OLD_VALUE, NEW_VALUE, CHANGE_DATE)
    VALUES (v_username, v_action, v_old_value, v_new_value, SYSTIMESTAMP);
END;

-- Выполняем нужные действия!
INSERT INTO LW1_TEAM(name, members) VALUES ('Test Trigger 1', 10);
UPDATE LW1_TEAM SET MEMBERS = 11 WHERE NAME = 'Test Trigger 1';
DELETE FROM LW1_TEAM WHERE NAME = 'Test Trigger 1';

-- Смотрим содержимое таблицы с логами!

SELECT * FROM LOG1;

--Очищаем таблицу

TRUNCATE table LOG1;

-- 2.   Написать DDL-триггер, протоколирующий действия пользователей по созданию, изменению и
-- удалению таблиц в схеме во вспомогательную табли-цу LOG2 в определенное время и запрещающий
-- эти действия в другое время.

CREATE TABLE LOG2
(
    log_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_date  TIMESTAMP DEFAULT SYSTIMESTAMP,
    username    VARCHAR2(30),
    action_type VARCHAR2(20),
    object_name VARCHAR2(50),
    status      VARCHAR2(10)
);

CREATE TABLE ALLOWED_WORK_TIME
(
    start_time NUMBER(2),
    end_time   NUMBER(2)
);

INSERT INTO ALLOWED_WORK_TIME (start_time, end_time) VALUES (9, 18);

-- Изменить разрешенное время работы!
UPDATE ALLOWED_WORK_TIME SET START_TIME = 0, END_TIME =24;

CREATE OR REPLACE TRIGGER ddl_audit_trigger
    BEFORE CREATE OR ALTER OR DROP ON SCHEMA
DECLARE
    v_hour NUMBER;
    v_start_time NUMBER;
    v_end_time NUMBER;
    outside_work_hours EXCEPTION;
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    -- Получение текущего часа
    v_hour := EXTRACT(HOUR FROM SYSTIMESTAMP);

    -- Получение разрешенного времени работы
    SELECT start_time, end_time INTO v_start_time, v_end_time
    FROM ALLOWED_WORK_TIME WHERE ROWNUM = 1;

    -- Проверка времени выполнения операции
    IF v_hour < v_start_time OR v_hour >= v_end_time THEN
        RAISE outside_work_hours;
    END IF;

    -- Логирование успешной операции
    INSERT INTO LOG2 (username, action_type, object_name, status)
    VALUES ( ora_login_user, ora_sysevent, ora_dict_obj_name, 'ALLOWED');

    COMMIT;
EXCEPTION
    WHEN outside_work_hours THEN
        -- Логирование запрещенной операции
        INSERT INTO LOG2 (username, action_type, object_name, status)
        VALUES (ora_login_user, ora_sysevent, ora_dict_obj_name, 'DENIED');
        COMMIT;
        RAISE_APPLICATION_ERROR(-20001, 'DDL операции разрешены только с ' ||
                                        v_start_time || ':00 до ' ||
                                        v_end_time || ':00. Текущее время: ' ||
                                        TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS'));
    WHEN OTHERS THEN
        -- Логирование ошибки
        INSERT INTO LOG2 (username, action_type, object_name, status)
        VALUES (ora_login_user, ora_sysevent, ora_dict_obj_name, 'ERROR');
        COMMIT;
        RAISE;
END;

--Проверка!
CREATE TABLE TEST(id INTEGER);

DROP TABLE TEST;

SELECT * FROM LOG2 ORDER BY
    EVENT_DATE DESC;
-- 3.   Написать системный триггер, добавляющий запись во вспомогатель-ную таблицу LOG3, когда
-- пользователь подключается или отключается. В таблицу логов записывается имя пользователя (USER),
-- тип активности (LOGON или LOGOFF), дата (SYSDATE), количество записей в основной таблице БД.

CREATE TABLE LOG3
(
    log_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username      VARCHAR2(30),
    activity_type VARCHAR2(10),
    log_date      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    record_count  NUMBER
);

CREATE OR REPLACE TRIGGER log_user_activity
    AFTER LOGON ON DATABASE
DECLARE
    v_record_count NUMBER;
BEGIN
    -- Получаем количество записей в основной таблице
    SELECT COUNT(*)
    INTO v_record_count
    FROM LW1_PROJECT;

    -- Вставляем запись о логине в таблицу логов
    INSERT INTO LOG3 (username, activity_type, record_count)
    VALUES (USER, 'LOGON', v_record_count);
END;

CREATE OR REPLACE TRIGGER log_user_activity_off
    BEFORE LOGOFF ON DATABASE
DECLARE
    v_record_count NUMBER;
BEGIN
    -- Получаем количество записей в основной таблице
    SELECT COUNT(*) INTO v_record_count FROM LW1_PROJECT;

    -- Вставляем запись о логауте в таблицу логов
    INSERT INTO LOG3 (username, activity_type, record_count)
    VALUES (USER, 'LOGOFF', v_record_count);
END;

-- Посмотреть логи подключений / отключений!

SELECT * FROM LOG3;

TRUNCATE table LOG3;

-- 4.   Написать триггеры, реализующие бизнес-логику (ограничения) в за-данной вариантом предметной
-- области. Три задания приведены в прил. 6. Ко-личество и тип триггеров (строковый или операторный,
-- выполняется AFTER или BEFORE) определять самостоятельно исходя из сути заданий и имею-щейся схемы
-- БД; учесть, что в некоторых вариантах первые два задания мо-гут быть выполнены в рамках одного
-- триггера, а также возможно возникно-вение мутации, что приведет к совмещению данного пункта
-- лабораторной работы со следующим. Третий пункт задания предполагает использование планировщика
-- задач, который обязательно должен быть настроен на много-кратный запуск с использованием
-- частоты, интервала и спецификаторов.

-- 1)   Отслеживать последовательное выполнение этапов по каждому объ-екту строительства
-- с учетом сроков на выполнение.

-- Создаем таблицу для этапов строительства
CREATE TABLE LW1_construction_stages
(
    id                 NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    project_id         NUMBER                                  NOT NULL,
    stage_name         VARCHAR2(255)                           NOT NULL,
    stage_order        NUMBER                                  NOT NULL,
    planned_start_date DATE                                    NOT NULL,
    planned_end_date   DATE                                    NOT NULL,
    actual_start_date  DATE,
    actual_end_date    DATE,
    CONSTRAINT pk_construction_stages PRIMARY KEY (id),
    CONSTRAINT fk_stages_project FOREIGN KEY (project_id) REFERENCES LW1_project (id)
);

CREATE OR REPLACE TRIGGER trg_check_construction_stages
    FOR INSERT OR UPDATE
    ON LW1_construction_stages
    COMPOUND TRIGGER

-- Создаем таблицу = тип данных
    TYPE t_stage_rec IS RECORD
                        (
                            project_id        NUMBER,
                            stage_order       NUMBER,
                            actual_start_date DATE,
                            actual_end_date   DATE,
                            planned_end_date  DATE
                        );

    TYPE t_stages_tab IS TABLE OF t_stage_rec INDEX BY INTEGER;
--Создаем таблицу, существующую только в триггере
    l_stages t_stages_tab;
    l_idx INTEGER := 0;

-- Секция BEFORE EACH ROW - строковый триггер
BEFORE EACH ROW IS
BEGIN
    l_idx := l_idx + 1;
    -- Сохраняем данные во временную таблицу
    l_stages(l_idx).project_id := :NEW.project_id;
    l_stages(l_idx).stage_order := :NEW.stage_order;
    l_stages(l_idx).actual_start_date := :NEW.actual_start_date;
    l_stages(l_idx).actual_end_date := :NEW.actual_end_date;
    l_stages(l_idx).planned_end_date := :NEW.planned_end_date;

    -- Базовая проверка, не требующие доступа к таблице
    IF :NEW.actual_end_date IS NOT NULL AND :NEW.actual_start_date IS NOT NULL THEN
        IF :NEW.actual_end_date < :NEW.actual_start_date THEN
            RAISE_APPLICATION_ERROR(-20003, 'Дата завершения не может быть раньше даты начала');
        END IF;
    END IF;
END BEFORE EACH ROW;

--Секция после запроса - операторный триггер
    AFTER STATEMENT IS
        v_prev_stage_end   DATE;
        v_next_stage_start DATE;
    BEGIN
        -- Обрабатываем сохраненные данные
        FOR i IN 1..l_idx
            LOOP
                -- Проверяем предыдущий этап
                IF l_stages(i).stage_order > 1 THEN
                    SELECT actual_end_date
                    INTO v_prev_stage_end
                    FROM LW1_construction_stages
                    WHERE project_id = l_stages(i).project_id
                      AND stage_order = l_stages(i).stage_order - 1;

                    IF v_prev_stage_end IS NULL THEN
                        RAISE_APPLICATION_ERROR(-20001,
                                                'Предыдущий этап должен быть завершен для этапа ' ||
                                                l_stages(i).stage_order);
                    END IF;

                    IF l_stages(i).actual_start_date < v_prev_stage_end THEN
                        RAISE_APPLICATION_ERROR(-20002,
                                                'Этап ' || l_stages(i).stage_order ||
                                                ' не может начаться раньше завершения предыдущего');
                    END IF;
                END IF;

                -- Проверяем следующий этап
                IF l_stages(i).actual_end_date IS NOT NULL THEN
                    BEGIN
                        SELECT actual_start_date
                        INTO v_next_stage_start
                        FROM LW1_construction_stages
                        WHERE project_id = l_stages(i).project_id
                          AND stage_order = l_stages(i).stage_order + 1;

                        IF v_next_stage_start IS NOT NULL AND
                           l_stages(i).actual_end_date > v_next_stage_start THEN
                            RAISE_APPLICATION_ERROR(-20004,
                                                    'Завершение этапа ' ||
                                                    l_stages(i).stage_order ||
                                                    ' нарушает начало следующего этапа');
                        END IF;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            NULL; -- Следующего этапа нет, это нормально
                    END;
                END IF;

                -- Проверяем превышение плановых сроков
                IF l_stages(i).actual_end_date > l_stages(i).planned_end_date THEN
                    DBMS_OUTPUT.PUT_LINE(
                            'Предупреждение: превышение планового срока завершения этапа ' ||
                            l_stages(i).stage_order);
                END IF;
            END LOOP;
    END AFTER STATEMENT;
    END trg_check_construction_stages;

-- Создадим временную бригаду для проверки!
INSERT INTO LW1_TEAM(ID, NAME, MEMBERS) VALUES (-100000, 'Temporary Team to check trigger', 10);

-- Создадим временного клиента для проверки!
INSERT INTO LW1_CLIENT(ID, NAME, PHONE, EMAIL) VALUES (-100000, 'Temporary Client to check trigger', '+375(29)211-11-11', 'email@email.com');

-- Создадим временный проект для проверки!
INSERT INTO LW1_PROJECT(ID, CLIENT_ID, TEAM_ID, TYPE, PRICE, START_DATE, "DATE", DESCRIPTION)
VALUES (-100000, -100000, -100000, 'Concrete', 100000, TO_DATE('01.01.2024', 'dd.mm.YYYY'),
        TO_DATE('31.03.2024', 'dd.mm.YYYY'), 'Description');

-- Создание первого этапа будет успешно!
INSERT INTO LW1_CONSTRUCTION_STAGES(id, project_id, stage_name, stage_order, planned_start_date, planned_end_date, actual_start_date, actual_end_date)
VALUES (-100000, -100000, 'Stage 1', 1, TO_DATE('01.01.2024', 'dd.mm.YYYY'), TO_DATE('31.01.2024', 'dd.mm.YYYY'), TO_DATE('01.01.2024', 'dd.mm.YYYY'), null);

-- Создание второго этапа должно провалиться из-за незавершенного первого!
INSERT INTO LW1_CONSTRUCTION_STAGES(id, project_id, stage_name, stage_order, planned_start_date, planned_end_date, actual_start_date, actual_end_date)
VALUES (-100001, -100000, 'Stage 2', 2, TO_DATE('01.02.2024', 'dd.mm.YYYY'), TO_DATE('28.02.2024', 'dd.mm.YYYY'), TO_DATE('01.02.2024', 'dd.mm.YYYY'), null);

-- Завершим первый этап!
UPDATE LW1_CONSTRUCTION_STAGES SET actual_end_date = TO_DATE('31.01.2024', 'dd.mm.YYYY') WHERE id = -100000;

-- Вторая попытка создать второй этап: провалиться из-за того, что дата начала будет раньше даты конца прошлого этапа!
INSERT INTO LW1_CONSTRUCTION_STAGES(id, project_id, stage_name, stage_order, planned_start_date, planned_end_date, actual_start_date, actual_end_date)
VALUES (-100001, -100000, 'Stage 2', 2, TO_DATE('01.02.2024', 'dd.mm.YYYY'), TO_DATE('28.02.2024', 'dd.mm.YYYY'), TO_DATE('15.01.2024', 'dd.mm.YYYY'), null);

-- Третья попытка создать второй этап будет успешной, но выдаст предупреждение, о превышении сроков!
INSERT INTO LW1_CONSTRUCTION_STAGES(id, project_id, stage_name, stage_order, planned_start_date, planned_end_date, actual_start_date, actual_end_date)
VALUES (-100001, -100000, 'Stage 2', 2, TO_DATE('01.02.2024', 'dd.mm.YYYY'), TO_DATE('28.02.2024', 'dd.mm.YYYY'), TO_DATE('01.02.2024', 'dd.mm.YYYY'), TO_DATE('15.03.2024', 'dd.mm.YYYY'));

-- Удалим временные сущности!
DECLARE BEGIN
    DELETE FROM LW1_CONSTRUCTION_STAGES WHERE id IN (-100001, -100000);
    DELETE FROM LW1_PROJECT WHERE ID IN (-100000);
    DELETE FROM LW1_TEAM WHERE ID IN (-100000);
    DELETE FROM LW1_CLIENT WHERE ID IN (-100000);
END;

TRUNCATE TABLE LW1_CONSTRUCTION_STAGES;

-- 2)   Контролировать наличие материалов, занятость бригад и сроки строительства;
-- не допускать одновременного строительства более трех объек-тов.

CREATE OR REPLACE TRIGGER trg_control_project_count
    BEFORE INSERT OR UPDATE ON LW1_project
    FOR EACH ROW
DECLARE
    v_concurrent_projects NUMBER;
    v_too_many_projects EXCEPTION;
BEGIN
    -- Подсчет количества параллельных проектов
    SELECT COUNT(*)
    INTO v_concurrent_projects
    FROM LW1_project
    WHERE id != :NEW.id
      AND start_date <= :NEW.date
      AND "DATE" >= :NEW.start_date;

    IF v_concurrent_projects >= 3 THEN
        RAISE v_too_many_projects;
    END IF;

EXCEPTION
    WHEN v_too_many_projects THEN
        RAISE_APPLICATION_ERROR(-20003, 'Превышено максимальное количество одновременных проектов (3)');
END;

-- Триггер для проверки ресурсов при назначении материалов
CREATE OR REPLACE TRIGGER trg_control_material_assignment
    BEFORE INSERT OR UPDATE ON LW1_material_for_project
    FOR EACH ROW
DECLARE
    v_available_qty NUMBER;
    v_used_qty NUMBER;
    v_material_name VARCHAR2(255);
    v_material_shortage EXCEPTION;
BEGIN
    -- Получаем доступное количество материала
    SELECT name, quantity
    INTO v_material_name, v_available_qty
    FROM LW1_material
    WHERE id = :NEW.material_id;

    -- Считаем общее количество материала, уже назначенного на другие проекты
    SELECT NVL(SUM(mfp.quantity), 0)
    INTO v_used_qty
    FROM LW1_material_for_project mfp
             JOIN LW1_project p ON p.id = mfp.project_id
    WHERE mfp.material_id = :NEW.material_id
      AND p.id != :NEW.project_id
      AND p.start_date <= (SELECT "DATE" FROM LW1_project WHERE id = :NEW.project_id)
      AND p."DATE" >= (SELECT start_date FROM LW1_project WHERE id = :NEW.project_id);

    -- Проверяем достаточность материала
    IF :NEW.quantity + v_used_qty > v_available_qty THEN
        RAISE v_material_shortage;
    END IF;

EXCEPTION
    WHEN v_material_shortage THEN
        RAISE_APPLICATION_ERROR(-20001, 'Недостаточно материалов: ' || v_material_name ||
                                        '. Требуется: ' || :NEW.quantity || ', Доступно: ' || (v_available_qty - v_used_qty));
END;

-- Триггер для проверки ресурсов при назначении техники
CREATE OR REPLACE TRIGGER trg_control_tech_assignment
    BEFORE INSERT OR UPDATE ON LW1_tech_for_project
    FOR EACH ROW
DECLARE
    v_used_qty NUMBER;
    v_tech_name VARCHAR2(255);
    v_tech_shortage EXCEPTION;
BEGIN
    -- Получаем название техники
    SELECT name
    INTO v_tech_name
    FROM LW1_tech
    WHERE id = :NEW.tech_id;

    -- Считаем количество единиц техники, уже назначенной на другие проекты
    SELECT NVL(SUM(tfp.quantity), 0)
    INTO v_used_qty
    FROM LW1_tech_for_project tfp
             JOIN LW1_project p ON p.id = tfp.project_id
    WHERE tfp.tech_id = :NEW.tech_id
      AND p.id != :NEW.project_id
      AND p.start_date <= (SELECT "DATE" FROM LW1_project WHERE id = :NEW.project_id)
      AND p."DATE" >= (SELECT start_date FROM LW1_project WHERE id = :NEW.project_id);

    -- Проверяем доступность техники
    IF :NEW.quantity + v_used_qty > 1 THEN
        RAISE v_tech_shortage;
    END IF;

EXCEPTION
    WHEN v_tech_shortage THEN
        RAISE_APPLICATION_ERROR(-20002, 'Техника ' || v_tech_name ||
                                        ' уже используется в других проектах в этот период');
END;

-- Заполняем тестовые данные!
DECLARE BEGIN
    -- Заполним справочные данные
    INSERT INTO LW1_supplier (id, name) VALUES (-100000, 'ООО Стройматериалы');
    INSERT INTO LW1_supplier (id, name) VALUES (-100001, 'ООО Техника');

    -- Создадим временные материалы и технику для проверки
    INSERT INTO LW1_MATERIAL (ID, NAME, QUANTITY, UNIT, SUPPLIER_ID)
    VALUES (-100000, 'Temporary material to check trigger', 50, 'unit', -100000);

    INSERT INTO LW1_TECH (ID, NAME, SUPPLIER_ID)
    VALUES (-100000, 'Temporary tech to check trigger', -100000);

    -- Создадим временную бригаду для проверки
    INSERT INTO LW1_TEAM(ID, NAME, MEMBERS) VALUES (-100000, 'Temporary Team to check trigger', 10);

    -- Создадим временного клиента для проверки
    INSERT INTO LW1_CLIENT(ID, NAME, PHONE, EMAIL) VALUES (-100000, 'Temporary Client to check trigger', '+375(29)211-11-11', 'email@email.com');

    -- Создадим временный проект для проверки
    INSERT INTO LW1_PROJECT(ID, CLIENT_ID, TEAM_ID, TYPE, PRICE, START_DATE, "DATE", DESCRIPTION)
    VALUES (-100000, -100000, -100000, 'Concrete', 100000, TO_DATE('01.01.2021', 'dd.mm.YYYY'),
            TO_DATE('31.03.2021', 'dd.mm.YYYY'), 'Description');

    -- Создадим второй временный проект для проверки
    INSERT INTO LW1_PROJECT(ID, CLIENT_ID, TEAM_ID, TYPE, PRICE, START_DATE, "DATE", DESCRIPTION)
    VALUES (-100001, -100000, -100000, 'Concrete', 100000, TO_DATE('01.01.2020', 'dd.mm.YYYY'),
            TO_DATE('31.03.2020', 'dd.mm.YYYY'), 'Description');
END;

-- Создадим третий временный проект для проверки: провалено, слишком много одновременных проектов!
INSERT INTO LW1_PROJECT(ID, CLIENT_ID, TEAM_ID, TYPE, PRICE, START_DATE, "DATE", DESCRIPTION)
VALUES (-100002, -100000, -100000, 'Concrete', 100000, TO_DATE('01.01.2026', 'dd.mm.YYYY'),
        TO_DATE('31.03.2026', 'dd.mm.YYYY'), 'Description');

-- Добавляем технику - успешно!
INSERT INTO LW1_TECH_FOR_PROJECT(TECH_ID, PROJECT_ID, QUANTITY)
VALUES (-100000, -100000, 1);

-- Попытка добавить данную технику еще раз провалиться, поскольку она уже используется!
INSERT INTO LW1_TECH_FOR_PROJECT(TECH_ID, PROJECT_ID, QUANTITY)
VALUES (-100000, -100001, 1);

-- Попытка использовать больше материалов, чем доступо провалиться!
INSERT INTO LW1_MATERIAL_FOR_PROJECT(MATERIAL_ID, PROJECT_ID, QUANTITY)
VALUES (-100000, -100000, 100);

-- Очистить тестовые данные!
DECLARE BEGIN
    DELETE FROM LW1_MATERIAL_FOR_PROJECT WHERE MATERIAL_ID IN (-100000);
    DELETE FROM LW1_TECH_FOR_PROJECT WHERE TECH_ID IN (-100000);
    DELETE FROM LW1_MATERIAL WHERE ID IN (-100000);
    DELETE FROM LW1_TECH WHERE ID IN (-100000);
    DELETE FROM LW1_SUPPLIER WHERE ID IN (-100000, -100001);
    DELETE FROM LW1_PROJECT WHERE ID IN (-100000, -100001, -100002);
    DELETE FROM LW1_CLIENT WHERE ID IN (-100000);
    DELETE FROM LW1_TEAM WHERE ID IN (-100000);
END;

-- 3)   Если последний этап строительства завершен, то сохранить данные в дополнительной таблице
-- «Построенные объекты», где указывать данные об объекте и количество дней,
-- потраченных на строительство.

CREATE TABLE LW5_FINISHED_OBJECTS
(
    id         NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    client_id  NUMBER                                  NOT NULL,
    team_id    NUMBER                                  NOT NULL,
    type       VARCHAR2(255)                           NOT NULL,
    price      DECIMAL(38, 2)                          NOT NULL,
    start_date DATE                                    NOT NULL,
    "DATE"     DATE                                    NOT NULL,
    days       NUMBER                                  NOT NULL
);

CREATE OR REPLACE PROCEDURE find_closed_projects AS
BEGIN
    -- Очищаем таблицу
    DELETE FROM LW5_FINISHED_OBJECTS;

    -- Заполняем таблицу данными, соответствующими условиям
    INSERT INTO LW5_FINISHED_OBJECTS (ID, CLIENT_ID, TEAM_ID, "TYPE", PRICE, START_DATE, "DATE", DAYS)
    SELECT ID, CLIENT_ID, TEAM_ID, "TYPE", PRICE, START_DATE, "DATE", "DATE" - START_DATE
    FROM LW1_PROJECT
    WHERE "DATE" <= SYSDATE;
END;

-- Добавим завершенный проект:
INSERT INTO LW1_PROJECT(CLIENT_ID, TEAM_ID, TYPE, PRICE, START_DATE, "DATE", DESCRIPTION)
VALUES (1, -1, 'Composite', 1000, TO_DATE('2024-10-10', 'YYYY-MM-DD'),
        TO_DATE('2024-10-20', 'YYYY-MM-DD'), 'dsd');

DELETE FROM LW1_PROJECT WHERE id = 45;

--Добавляем задание в планировщик задач
BEGIN
    BEGIN
    -- Drop the existing job
    DBMS_SCHEDULER.DROP_JOB(job_name => 'find_closed_projects_job', force => TRUE);
    EXCEPTION WHEN OTHERS THEN
        IF SQLCODE != -27475 THEN
            RAISE;
        END IF;
    END;

    -- Create a new job to run every minute
    DBMS_SCHEDULER.CREATE_JOB(
            job_name        => 'find_closed_projects_job',      -- Job name
            job_type        => 'PLSQL_BLOCK',                    -- Job type
            job_action      => 'BEGIN find_closed_projects; END;', -- Job action
            start_date      => SYSTIMESTAMP,                     -- Start time
            repeat_interval => 'FREQ=MINUTELY; INTERVAL=1',      -- Run every minute
            enabled         => TRUE                               -- Enable the job
    );
END;

SELECT * FROM LW5_FINISHED_OBJECTS;

DROP TRIGGER trg_team_log;
-- 5.   Самостоятельно или при помощи преподавателя составить задание на триггер, который будет
-- вызывать мутацию таблиц, и решить эту проблему одним из двух способов (при помощи переменных
-- пакета и двух триггеров или при помощи COMPAUND-триггера).

-- Решено в предыдущем задании!

-- 6.   Написать триггер INSTEAD OF для работы с не обновляемым пред-ставлением, созданным после
-- выполнения п. 2.4 задания к лабораторной ра-боте №3, проверить DML-командами возможность
-- обновления представления после включения триггера (логика работы триггера определяется
-- спецификой предметной области варианта).

CREATE OR REPLACE TRIGGER trg_create_project_team
    INSTEAD OF INSERT OR UPDATE OR DELETE
    ON LW1_PROJECT_TEAM
DECLARE
    v_new_team_id NUMBER;
BEGIN
    CASE
        WHEN INSERTING THEN
            IF :NEW.PROJECT_ID IS NULL THEN
                IF :NEW.TEAM_ID IS NOT NULL THEN
                    UPDATE LW1_TEAM SET "NAME" = :NEW."NAME" WHERE ID = :NEW.TEAM_ID;
                ELSE
                    INSERT INTO LW1_TEAM(NAME, MEMBERS) VALUES (:NEW."NAME", 10);
                END IF;
                RETURN;
            END IF;

            IF :NEW.TEAM_ID IS NOT NULL THEN
                UPDATE LW1_PROJECT SET TEAM_ID = :NEW.TEAM_ID WHERE LW1_PROJECT.ID = :NEW.PROJECT_ID;
                v_new_team_id := :NEW.TEAM_ID;
            ELSE
                INSERT INTO LW1_TEAM (NAME, MEMBERS) VALUES ('Unnamed team', 10) RETURNING ID INTO v_new_team_id;
                UPDATE LW1_PROJECT
                SET TEAM_ID = v_new_team_id
                WHERE ID = :NEW.PROJECT_ID;
            END IF;

            IF :NEW."NAME" IS NOT NULL THEN
                UPDATE LW1_TEAM
                SET NAME = :NEW."NAME"
                WHERE ID = v_new_team_id;
            END IF;

        WHEN UPDATING THEN
            IF :NEW.PROJECT_ID <> :OLD.PROJECT_ID THEN
                RAISE_APPLICATION_ERROR(-20001, 'Cannot update project id.');
            END IF;

            IF :NEW.TEAM_ID <> :OLD.TEAM_ID THEN
                UPDATE LW1_PROJECT SET TEAM_ID = :NEW.TEAM_ID WHERE LW1_PROJECT.ID = :OLD.PROJECT_ID;
                v_new_team_id := :NEW.TEAM_ID;
            ELSE
                v_new_team_id := :OLD.TEAM_ID;
            END IF;

            UPDATE LW1_TEAM SET LW1_TEAM."NAME" = :NEW."NAME" WHERE LW1_TEAM.ID = v_new_team_id;

        WHEN DELETING THEN
            DELETE FROM LW1_PROJECT WHERE LW1_PROJECT.ID = :OLD.PROJECT_ID AND LW1_PROJECT.TEAM_ID = :OLD.TEAM_ID;

        END CASE;
END;

-- Тест!
SET SERVEROUTPUT ON;
DECLARE
    v_temp VARCHAR2(255);
    FUNCTION GET_ROW_STRING RETURN VARCHAR2 IS
        p_row LW1_PROJECT_TEAM%ROWTYPE;
    BEGIN
        SELECT * INTO p_row FROM LW1_PROJECT_TEAM WHERE PROJECT_ID = 2;
        RETURN 'Project ID: ' || p_row.PROJECT_ID || ', Team ID: ' || p_row.TEAM_ID || ', Team name: ' || p_row."NAME";
    END GET_ROW_STRING;
BEGIN
    UPDATE LW1_PROJECT SET TEAM_ID = 1 WHERE ID = 2;
    UPDATE LW1_TEAM SET "NAME" = 'Team ' || ID;

    DBMS_OUTPUT.PUT_LINE('Исходные данные: ' || GET_ROW_STRING());

    DBMS_OUTPUT.PUT_LINE('Выполняем INSERT INTO LW1_PROJECT_TEAM VALUES (null, 1, team new name);');
    INSERT INTO LW1_PROJECT_TEAM VALUES (null, 1, 'team new name');
    DBMS_OUTPUT.PUT_LINE('Результат: ' || GET_ROW_STRING());

    DBMS_OUTPUT.PUT_LINE('Выполняем INSERT INTO LW1_PROJECT_TEAM VALUES (null, null, new team without id);');
    INSERT INTO LW1_PROJECT_TEAM VALUES (null, null, 'new team without id');
    SELECT 'Project ID: ' || PROJECT_ID || ', Team ID: ' || TEAM_ID || 'Team name: ' || "NAME" INTO v_temp FROM LW1_PROJECT_TEAM WHERE "NAME" = 'new team without id';
    DBMS_OUTPUT.PUT_LINE('Результат: ' || v_temp);
    DELETE FROM LW1_TEAM WHERE "NAME" = 'new team without id';

    DBMS_OUTPUT.PUT_LINE('Выполняем INSERT INTO LW1_PROJECT_TEAM VALUES (2, 2, null);');
    INSERT INTO LW1_PROJECT_TEAM VALUES (2, 2, null);
    DBMS_OUTPUT.PUT_LINE('Результат: ' || GET_ROW_STRING());

    DBMS_OUTPUT.PUT_LINE('Выполняем INSERT INTO LW1_PROJECT_TEAM VALUES (2, 2, New name);');
    INSERT INTO LW1_PROJECT_TEAM VALUES (2, 2, 'New name');
    DBMS_OUTPUT.PUT_LINE('Результат: ' || GET_ROW_STRING());

    DBMS_OUTPUT.PUT_LINE('Выполняем INSERT INTO LW1_PROJECT_TEAM VALUES (2, null, New team);');
    INSERT INTO LW1_PROJECT_TEAM VALUES (2, null, 'New team');
    DBMS_OUTPUT.PUT_LINE('Результат: ' || GET_ROW_STRING());

    DBMS_OUTPUT.PUT_LINE('Выполняем UPDATE LW1_PROJECT_TEAM SET TEAM_NAME = Renamed team without TEAM_ID WHERE PROJECT_ID = 2;');
    UPDATE LW1_PROJECT_TEAM SET "NAME" = 'Renamed team without TEAM_ID' WHERE PROJECT_ID = 2;
    DBMS_OUTPUT.PUT_LINE('Результат: ' || GET_ROW_STRING());

    DBMS_OUTPUT.PUT_LINE('Выполняем DELETE FROM LW1_PROJECT_TEAM WHERE PROJECT_ID = 2;');
    BEGIN
        DELETE FROM LW1_PROJECT_TEAM WHERE PROJECT_ID = 2;
        DBMS_OUTPUT.PUT_LINE('Результат: ' || GET_ROW_STRING());
    EXCEPTION WHEN no_data_found THEN
        DBMS_OUTPUT.PUT_LINE('No data found.');
        ROLLBACK;
    END;
END;

SELECT * FROM LW1_PROJECT_TEAM;
UPDATE LW1_PROJECT_TEAM SET "NAME" = 'huyamba' WHERE "NAME" = 'NEW NEW NEW NAME';

--адейт расширить функционал без привязки к айдишникам
